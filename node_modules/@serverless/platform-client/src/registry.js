'use strict';

/*
 * SERVERLESS PLATFORM SDK: REGISTRY
 */

const path = require('path');
const fs = require('fs');
const { tmpdir } = require('os');
const axios = require('axios');
const utils = require('./utils');

/**
 * Validates and (re)formats the package properties
 */
const validateAndFormat = (registryPackageRaw) => {
  // Copy input object, otherwise the inputter will have unintended data modifications
  const registryPackage = Object.assign({}, registryPackageRaw);

  if (!registryPackage.name) {
    throw new Error("The 'name' property is required");
  }

  if (!registryPackage.version) {
    throw new Error("The 'version' property is required");
  }

  // Ensure "dev" version uses correct syntax
  if (registryPackage.version === 'dev') {
    registryPackage.version = '0.0.0-dev';
  }

  // Format Helper - If shortened properties are used, replace them with full properties
  if (registryPackage.org) {
    registryPackage.orgName = registryPackage.org;
    delete registryPackage.org;
  }

  if (!registryPackage.orgName) {
    throw new Error("'orgName' is required");
  }
  if (!registryPackage.src) {
    throw new Error("'src' is required");
  }
  if (!registryPackage.type) {
    throw new Error("'type' is required");
  }

  // Validate and format Provider & Action Types
  if (registryPackage.providers) {
    registryPackage.types = registryPackage.types || {};
    registryPackage.types.providers = registryPackage.providers;
    delete registryPackage.providers;
  }
  if (registryPackage.actions) {
    registryPackage.types = registryPackage.types || {};
    registryPackage.types.actions = registryPackage.actions;
    delete registryPackage.actions;
  }

  return registryPackage;
};

const omit = (content, propsToOmit = []) => {
  for (const prop of propsToOmit) {
    const omitRegex = new RegExp(`^${prop}\\s*:\\s+.*$`, 'm');
    content = content.replace(omitRegex, () => '');
  }

  // remove extra blank lines
  return content.replace(/(\r\n|\r|\n){2,}/g, '$1\n');
};

/*
 * Returns a serverless config file from the given dir
 */
const getConfigFile = async (directoryPath, propsToOmit) => {
  const directoryName = path.basename(directoryPath);
  directoryPath = path.resolve(directoryPath);

  const ymlFilePath = path.join(directoryPath, 'serverless.yml');
  const yamlFilePath = path.join(directoryPath, 'serverless.yaml');
  const jsonFilePath = path.join(directoryPath, 'serverless.json');
  let filePath;

  // Check to see if exists and is yaml or json file
  if (utils.fileExistsSync(ymlFilePath)) {
    filePath = ymlFilePath;
  }
  if (utils.fileExistsSync(yamlFilePath)) {
    filePath = yamlFilePath;
  }
  if (utils.fileExistsSync(jsonFilePath)) {
    filePath = jsonFilePath;
  }
  if (!filePath) {
    return null;
  }

  const fileName = path.join(directoryName, path.basename(filePath));
  const fileContent = await fs.promises.readFile(filePath, 'utf-8');

  const configFile = {};
  configFile.fileName = fileName;
  configFile.fileContent = omit(fileContent, propsToOmit);

  return configFile;
};

const isDirectory = (fileOrDirPath) => {
  return fs.statSync(fileOrDirPath).isDirectory();
};

/*
 * Returns a list of serverless config files found in the given dir
 */
const getConfigFiles = async (root) => {
  const configFilesPromises = [];

  // list of properties we want to omit from config files
  const propsToOmit = [
    'org',
    'app',
    'service',
    'stage',
    'description',
    'keywords',
    'repo',
    'license',
    'service',
  ];

  const filesOrDirNames = await fs.promises.readdir(root);

  for (const fileOrDirName of filesOrDirNames) {
    const fileOrDirPath = path.join(root, fileOrDirName);

    // ignore hidden directories and files
    if (!fileOrDirName.startsWith('.') && isDirectory(fileOrDirPath)) {
      // find a config file in each directory
      configFilesPromises.push(getConfigFile(fileOrDirPath, propsToOmit));
    }
  }

  const configFiles = (await Promise.all(configFilesPromises)).filter((file) => file !== null);

  // get the root config file
  const rootConfigFile = 